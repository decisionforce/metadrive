# Author: @QuanyiLi. This terrain effect can texture road surface/road line. It is modified from:
# terrain-effect by @tobspr: https://github.com/tobspr/RenderPipeline
# Panda3D shader-terrain example: https://github.com/panda3d/panda3d/tree/master/samples/shader-terrain
# texture splatting @wezu: https://gist.github.com/wezu/3892a0a61ae9ddfe57c0aa3f22825ac0#file-terrain_tex_f-glsl-L49

vertex:
    inout: |
        uniform struct {
            sampler2D data_texture;
            sampler2D heightfield;
            int view_index;
            int terrain_size;
            int chunk_size;
        } ShaderTerrainMesh;
        out vec2 terrain_uv;

    transform: |
        // Terrain data has the layout:
        // x: x-pos, y: y-pos, z: size, w: clod
        vec4 terrain_data = texelFetch(ShaderTerrainMesh.data_texture,
        ivec2(gl_InstanceID, ShaderTerrainMesh.view_index), 0);

        // Get initial chunk position in the (0, 0, 0), (1, 1, 0) range
        vec3 chunk_position = p3d_Vertex.xyz;

        // CLOD implementation
        float clod_factor = smoothstep(0, 1, terrain_data.w);
        chunk_position.xy -= clod_factor * fract(chunk_position.xy * ShaderTerrainMesh.chunk_size / 2.0)
                              * 2.0 / ShaderTerrainMesh.chunk_size;

        // Scale the chunk
        chunk_position *= terrain_data.z * float(ShaderTerrainMesh.chunk_size)
                        / float(ShaderTerrainMesh.terrain_size);
        chunk_position.z *= ShaderTerrainMesh.chunk_size;

        // Offset the chunk, it is important that this happens after the scale
        chunk_position.xy += terrain_data.xy / float(ShaderTerrainMesh.terrain_size);

        // Compute the terrain UV coordinates
        terrain_uv = chunk_position.xy;

        // Sample the heightfield and offset the terrain - we do not need to multiply
        // the height with anything since the terrain transform is included in the
        // model view projection matrix.
        chunk_position.z += texture(ShaderTerrainMesh.heightfield, terrain_uv).x;

        // Lower the terrain on the borders - this ensures the shadow map is generated
        // correctly.
        if ( min(terrain_uv.x, terrain_uv.y) < 8.0 / ShaderTerrainMesh.terrain_size ||
           max(terrain_uv.x, terrain_uv.y) > 1 - 9.0 / ShaderTerrainMesh.terrain_size) {
           chunk_position.z = 0;
        }

        vOutput.position = (p3d_ModelMatrix * vec4(chunk_position, 1)).xyz;

fragment:
    defines: |
        #define DONT_FETCH_DEFAULT_TEXTURES 0
        #define DONT_SET_MATERIAL_PROPERTIES 1

    inout: |
        layout(location=4) in vec2 terrain_uv;
        
        in vec3 vtx_pos;
        
        out vec4 color;
        layout(location=5)  uniform struct {
          sampler2D data_texture;
          sampler2D heightfield;
          int view_index;
          int terrain_size;
          int chunk_size;
        } ShaderTerrainMesh;
        
        uniform vec3 wspos_camera;
        
        // texture for build road  
        uniform sampler2D detail_tex1;
        uniform sampler2D detail_tex2;
        uniform sampler2D detail_tex3;
        uniform sampler2D detail_tex4;
        uniform sampler2D road_normal;
        uniform sampler2D road_rough;
        uniform sampler2D attribute_tex;

    material: |
        if (terrain_uv.x>0.375 && terrain_uv.y >0.375 && terrain_uv.x<0.625 && terrain_uv.y<0.625){
            float terrain_ratio = 4.0;
            float tex_ratio = 32.0 * terrain_ratio;
            // texture splatting, mixing ratio can be determined via rgba
            vec3 diffuse = texture(detail_tex1, terrain_uv * tex_ratio).rgb * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).r;
            diffuse += texture(detail_tex2, terrain_uv * tex_ratio).rgb * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).g;
            diffuse += texture(detail_tex3, terrain_uv * tex_ratio).rgb * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).b;
            diffuse += texture(detail_tex4, terrain_uv * tex_ratio).rgb * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).a; 
            
            // Compute normal from the heightmap, this assumes the terrain is facing z-up
            const float terrain_height = 50.0;
            vec3 pixel_size = vec3(1.0, -1.0, 0) / textureSize(ShaderTerrainMesh.heightfield, 0).xxx;
            float u0 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.yz).x * terrain_height;
            float u1 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.xz).x * terrain_height;
            float v0 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.zy).x * terrain_height;
            float v1 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.zx).x * terrain_height;
            vec3 tangent = normalize(vec3(1.0, 0, u1 - u0));
            vec3 binormal = normalize(vec3(0, 1.0, v1 - v0));
            
            vec3 normal =  normalize(cross(tangent, binormal))*texture(attribute_tex, terrain_uv*terrain_ratio+0.5).r;
            normal +=  + normalize(texture(road_normal, terrain_uv * tex_ratio).rgb*2.0-1.0)*texture(attribute_tex, terrain_uv*terrain_ratio+0.5).g;
            normal +=  + normalize(texture(road_normal, terrain_uv * tex_ratio).rgb*2.0-1.0)*texture(attribute_tex, terrain_uv*terrain_ratio+0.5).b;
            normal +=  + normalize(texture(road_normal, terrain_uv * tex_ratio).rgb*2.0-1.0)*texture(attribute_tex, terrain_uv*terrain_ratio+0.5).a;
            
            // Add some fake lighting - you usually want to use your own lighting code here
            vec3 fake_sun = normalize(vec3(0.7, 0.2, 0.6));
            vec3 shading = max(0.0, dot(normal, fake_sun)) * diffuse;
            shading += vec3(0.07, 0.07, 0.1);
            
            
            // Fake fog
            // float dist = distance(vtx_pos, wspos_camera);
            // float fog_factor = smoothstep(0, 1, dist / 1000.0);
            // shading = mix(shading, vec3(0.7, 0.7, 0.8), fog_factor);
            
            color = vec4(shading, 1.0);
            
        
            m.shading_model = SHADING_MODEL_DEFAULT;
            m.specular_ior = 1.51;
            m.metallic = 0.0;
            m.roughness = 1.0 * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).r;
            m.roughness += texture(road_rough, terrain_uv * tex_ratio).r * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).g;
            m.roughness += texture(road_rough, terrain_uv * tex_ratio).r * texture(attribute_tex, terrain_uv*terrain_ratio+0.5).b;
            m.roughness += texture(road_rough, terrain_uv * tex_ratio).r *texture(attribute_tex, terrain_uv*terrain_ratio+0.5).a;
            m.shading_model_param0 = 0.0;
            m.normal = vec3(0);
            
            m.basecolor = diffuse.xyz;
            m.normal = normal.xyz;
        }
        else{
            // Compute terrain normal
            const float terrain_height = 1000.0;
            vec3 pixel_size = vec3(1.0, -1.0, 0) / textureSize(ShaderTerrainMesh.heightfield, 0).xxx;
            float h_u0 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.yz).x * terrain_height;
            float h_u1 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.xz).x * terrain_height;
            float h_v0 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.zy).x * terrain_height;
            float h_v1 = texture(ShaderTerrainMesh.heightfield, terrain_uv + pixel_size.zx).x * terrain_height;
            vec3 tangent = normalize(vec3(1, 0, h_u1 - h_u0));
            vec3 binormal = normalize(vec3(0, 1, h_v1 - h_v0));
            vec3 normal = normalize(cross(tangent, binormal));
    
            normal.x *= -1;
            // normal.y *= -1;
    
            // Material splatting
            float height = (h_u0 + h_u1 + h_v0 + h_v1) / (4.0 * terrain_height); // xxx
            float slope = 1.0 - normal.z;
            float grass = 0.0;
            float rock = 0.0;
            float snow = 0.0;
    
            { // Snow
                snow = saturate(4.0 * (height-0.49));
                snow *= saturate(pow(saturate(1.0 - slope), 2.0)) * 12.0;
    
                //snow -= 0.6;
                //snow *= 0.5;
                snow = saturate(snow);
                snow = pow(snow, 2.0);
            }
    
            { // Rock
                rock = saturate((pow(slope, 1.2) * 12.0 - 0.02) * 4.5);
            }
    
            { // Grass
                grass = 1.0 - saturate(rock + snow);
            }
    
    
            // Material definitions
    
            MaterialShaderOutput grass_mat = make_default_material_output();
            grass_mat.basecolor = vec3(0.1, 0.2, 0.1);
            grass_mat.roughness = 0.8;
    
            MaterialShaderOutput rock_mat = make_default_material_output();
            rock_mat.basecolor = vec3(0.13);
            rock_mat.roughness = 0.8;
            rock_mat.specular_ior = 1.4;
    
            MaterialShaderOutput snow_mat = make_default_material_output();
            snow_mat.basecolor = vec3(0.6, 0.6, 0.9);
            snow_mat.roughness = 0.5;
            snow_mat.specular_ior = 1.7;
    
            m.basecolor = vec3(0);
            m.shading_model = SHADING_MODEL_DEFAULT;
            m.specular_ior = 0.0;
            m.metallic = 0.0;
            m.roughness = 0.0;
            m.shading_model_param0 = 0.0;
            m.normal = vec3(0);
    
            merge_material_output(m, grass_mat, grass);
            merge_material_output(m, rock_mat, rock);
            merge_material_output(m, snow_mat, snow);
    
            m.normal = normal;
        }
        

